---
title: "Creating Tags Pages for Blog Posts"
date: "2020-04-13"
path: "/creating-tags-pages-for-blog-posts"
technologies:
  - nodejs
  - docker
description: "While most people enjoy casino gambling, sports betting, lottery and bingo playing for the fun and excitement it provides, others may experience gambling as an addictive and distractive habit. Statistics show that while 85 percent of the adult population in the US enjoys some type of gambling. "
---

# Add tags to your `markdown` files

You add tags by defining them in the `frontmatter` of your Markdown file. The `frontmatter` is the area at the top surrounded by dashes that includes post data like the title and date.

```markdown
---
title: "A Trip To the Zoo"
---

I went to the zoo today. It was terrible.
```

Fields can be strings, numbers, or arrays. Since a post can usually have many tags, it makes sense to define it as an array. Here you add your new tags field:

```markdown
---
title: "A Trip To the Zoo"
tags: ["animals", "Chicago", "zoos"]
---

I went to the zoo today. It was terrible.
```

If `gatsby develop` is running, restart it so Gatsby can pick up the new fields.

# Write a query to get all tags for your posts

Now, these fields are available in the data layer. To use field data, query it using `graphql`. All fields are available to query inside `frontmatter`

Try running the following query in Graph<em>i</em>QL (`http://localhost:8000/___graphql`):

```graphql
{
  allMarkdownRemark {
    group(field: frontmatter___tags) {
      tag: fieldValue
      totalCount
    }
  }
}
```

The above query groups posts by `tags`, and returns each `tag` with the number of posts as `totalCount`. As an addition, you could extract some post data in each group if you need to. To keep this tutorial small, you're only using the tag name in your tag pages. Make the tag page template now:

# Make a tags page template (for `/tags/{tag}`)

If you followed the tutorial for [Adding Markdown Pages](/docs/adding-markdown-pages/), then this process should sound familiar: Make a tag page template, then use it in `createPages` in `gatsby-node.js` to generate individual pages for the tags in your posts.

First, you'll add a tags template at `src/templates/tags.js`:

```jsx
import React from "react"
import PropTypes from "prop-types"

// Components
import { Link, graphql } from "gatsby"

const Tags = ({ pageContext, data }) => {
  const { tag } = pageContext
  const { edges, totalCount } = data.allMarkdownRemark
  const tagHeader = `${totalCount} post${
    totalCount === 1 ? "" : "s"
  } tagged with "${tag}"`

  return (
    <div>
      <h1>{tagHeader}</h1>
      <ul>
        {edges.map(({ node }) => {
          const { slug } = node.fields
          const { title } = node.frontmatter
          return (
            <li key={slug}>
              <Link to={slug}>{title}</Link>
            </li>
          )
        })}
      </ul>
      {/*
              This links to a page that does not yet exist.
              You'll come back to it!
            */}
      <Link to="/tags">All tags</Link>
    </div>
  )
}

Tags.propTypes = {
  pageContext: PropTypes.shape({
    tag: PropTypes.string.isRequired,
  }),
  data: PropTypes.shape({
    allMarkdownRemark: PropTypes.shape({
      totalCount: PropTypes.number.isRequired,
      edges: PropTypes.arrayOf(
        PropTypes.shape({
          node: PropTypes.shape({
            frontmatter: PropTypes.shape({
              title: PropTypes.string.isRequired,
            }),
            fields: PropTypes.shape({
              slug: PropTypes.string.isRequired,
            }),
          }),
        }).isRequired
      ),
    }),
  }),
}

export default Tags

export const pageQuery = graphql`
  query($tag: String) {
    allMarkdownRemark(
      limit: 2000
      sort: { fields: [frontmatter___date], order: DESC }
      filter: { frontmatter: { tags: { in: [$tag] } } }
    ) {
      totalCount
      edges {
        node {
          fields {
            slug
          }
          frontmatter {
            title
          }
        }
      }
    }
  }
`
```

**Note**: `propTypes` are included in this example to help you ensure you're getting all the data you need in the component, and to help serve as a guide while destructuring / using those props.

## Modify `gatsby-node.js` to render pages using that template

Now you've got a template. Great! Assuming you followed the tutorial for [Adding Markdown Pages](/docs/adding-markdown-pages/) and provide a sample `createPages` that generates post pages as well as tag pages. In the site's `gatsby-node.js` file, include `lodash` (`const _ = require('lodash')`) and then make sure your [`createPages`](/docs/node-apis/#createPages) looks something like this:

```js
const path = require("path")
const _ = require("lodash")

exports.createPages = async ({ actions, graphql, reporter }) => {
  const { createPage } = actions

  const blogPostTemplate = path.resolve("src/templates/blog.js")
  const tagTemplate = path.resolve("src/templates/tags.js")

  const result = await graphql(`
    {
      postsRemark: allMarkdownRemark(
        sort: { order: DESC, fields: [frontmatter___date] }
        limit: 2000
      ) {
        edges {
          node {
            fields {
              slug
            }
            frontmatter {
              tags
            }
          }
        }
      }
      tagsGroup: allMarkdownRemark(limit: 2000) {
        group(field: frontmatter___tags) {
          fieldValue
        }
      }
    }
  `)

  // handle errors
  if (result.errors) {
    reporter.panicOnBuild(`Error while running GraphQL query.`)
    return
  }

  const posts = result.data.postsRemark.edges

  // Create post detail pages
  posts.forEach(({ node }) => {
    createPage({
      path: node.fields.slug,
      component: blogPostTemplate,
    })
  })

  // Extract tag data from query
  const tags = result.data.tagsGroup.group

  // Make tag pages
  tags.forEach(tag => {
    createPage({
      path: `/tags/${_.kebabCase(tag.fieldValue)}/`,
      component: tagTemplate,
      context: {
        tag: tag.fieldValue,
      },
    })
  })
}
```

Some notes:

- Your GraphQL query only looks for data you need to generate these pages. Anything else can be queried again later (and, if you notice, you do this above in the tags template for the post title).
- You have referenced two `allMarkdownRemark` fields in your query. To avoid naming collisions you must [alias](/docs/graphql-reference/#aliasing) one of them. You alias both to make your code more human-readable.
- While making the tag pages, note that you pass `tag.name` through in the `context`. This is the value that gets used in the `TagPage` query to limit your search to only posts tagged with the tag in the URL.

## Make a tags index page (`/tags`) that renders a list of all tags

Your `/tags` page will simply list out all tags, followed by the number of posts with that tag. You can get the data with the first query you wrote earlier, that groups posts by tags:

```jsx
import React from "react"
import PropTypes from "prop-types"

// Utilities
import kebabCase from "lodash/kebabCase"

// Components
import { Helmet } from "react-helmet"
import { Link, graphql } from "gatsby"

const TagsPage = ({
  data: {
    allMarkdownRemark: { group },
    site: {
      siteMetadata: { title },
    },
  },
}) => (
  <div>
    <Helmet title={title} />
    <div>
      <h1>Tags</h1>
      <ul>
        {group.map(tag => (
          <li key={tag.fieldValue}>
            <Link to={`/tags/${kebabCase(tag.fieldValue)}/`}>
              {tag.fieldValue} ({tag.totalCount})
            </Link>
          </li>
        ))}
      </ul>
    </div>
  </div>
)

TagsPage.propTypes = {
  data: PropTypes.shape({
    allMarkdownRemark: PropTypes.shape({
      group: PropTypes.arrayOf(
        PropTypes.shape({
          fieldValue: PropTypes.string.isRequired,
          totalCount: PropTypes.number.isRequired,
        }).isRequired
      ),
    }),
    site: PropTypes.shape({
      siteMetadata: PropTypes.shape({
        title: PropTypes.string.isRequired,
      }),
    }),
  }),
}

export default TagsPage

export const pageQuery = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
    allMarkdownRemark(limit: 2000) {
      group(field: frontmatter___tags) {
        fieldValue
        totalCount
      }
    }
  }
`
```

# _(optional)_ Render tags inline with your blog posts

The home stretch! Anywhere else you'd like to render your tags, simply add them to the `frontmatter` section of your `graphql` query and access them in your component like any other prop.

# Java

```java
package fr.openent.webConference.bigbluebutton;

import fr.wseduc.webutils.Either;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Formatter;

public class BigBlueButton {
    private String host;
    private String apiEndpoint;
    private String secret;
    private String source;
    private static final Logger log = LoggerFactory.getLogger(BigBlueButton.class);
    private HttpClient httpClient;

    public static BigBlueButton getInstance() {
        return BigBlueButtonHolder.instance;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getSource() {
        return this.source;
    }

    public void setHost(Vertx vertx, String host) {
        this.host = host;
        try {
            URI uri = new URI(host);
            HttpClientOptions opts = new HttpClientOptions()
                    .setDefaultHost(host)
                    .setDefaultPort("https".equals(uri.getScheme()) ? 433 : 80)
                    .setSsl("https".equals(uri.getScheme()))
                    .setKeepAlive(true)
                    .setVerifyHost(false)
                    .setTrustAll(true);
            this.httpClient = vertx.createHttpClient(opts);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
    }

    public void setApiEndpoint(String apiEndpoint) {
        this.apiEndpoint = apiEndpoint;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }

    private String checksum(String value) {
        try {
            byte[] bytes = MessageDigest.getInstance("SHA-1").digest(value.getBytes());
            Formatter formatter = new Formatter();
            for (byte b : bytes) {
                formatter.format("%02x", b);
            }
            return formatter.toString();
        } catch (NoSuchAlgorithmException e) {
            log.error("[WebConference@BigBlueButton] Failed to generate checksum", e);
            return "";
        }
    }

    private Document parseResponse(Buffer response) {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputSource source = new InputSource(new StringReader(new String(response.getBytes())));
            Document xml = builder.parse(source);
            xml.getDocumentElement().normalize();
            return xml;
        } catch (ParserConfigurationException | IOException | SAXException e) {
            log.error("[WebConference@BigBlueButton] Failed to parse response", e);
            return null;
        }
    }

    private String encodeParams(String param) {
        String encodedName;
        try {
            encodedName = URLEncoder.encode(param, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            log.error("[WebConference@BigBlueButton] Failed to encode meeting name");
            encodedName = "";
        }

        return encodedName;
    }

    public String getRedirectURL(String sessionID, String userDisplayName, String password) {
        String encodedName = encodeParams(userDisplayName);
        String parameters = "fullName=" + encodedName + "&meetingID=" + sessionID + "&password=" + password;
        String checksum = checksum(Actions.JOIN + parameters + this.secret);
        String url = this.host + this.apiEndpoint + "/" + Actions.JOIN + "?" + parameters + "&checksum=" + checksum;
        return url;
    }

    public void create(String name, String meetingID, String moderatorPW, String attendeePW, String structure, String locale, Handler<Either<String, String>> handler) {
        String encodedName = encodeParams(name);
        String parameters = "name=" + encodedName + "&meetingID=" + meetingID + "&moderatorPW=" + moderatorPW + "&attendeePW=" + attendeePW;
        String checksum = checksum(Actions.CREATE + parameters + this.secret);
        parameters = parameters + "&checksum=" + checksum;
        HttpClientRequest request = httpClient.getAbs(this.host + this.apiEndpoint + "/" + Actions.CREATE + "?" + parameters, response -> {
            response.bodyHandler(body -> {
                try {
                    Document res = parseResponse(body);
                    XPathFactory xpf = XPathFactory.newInstance();
                    XPath path = xpf.newXPath();
                    String returnCode = path.evaluate("/response/returncode", res.getDocumentElement());

                    if (!"SUCCESS".equals(returnCode) || response.statusCode() != 200) {
                        String messageKey = path.evaluate("/response/messageKey", res.getDocumentElement());
                        if (ErrorCode.TOO_MANY_SESSIONS.code().equals(messageKey)) {
                            handler.handle(new Either.Left<>(ErrorCode.TOO_MANY_SESSIONS.code()));
                            return;
                        }

                        handler.handle(new Either.Left<>("[WebConference@BigBlueButton] Failed to create meeting"));
                        return;
                    }

                    String internalId = path.evaluate("/response/internalMeetingID", res.getDocumentElement());
                    if (internalId == null)
                        handler.handle(new Either.Left<>("[WebConference@BigBlueButton] No internal id"));
                    else handler.handle(new Either.Right<>(internalId));
                } catch (XPathExpressionException | NullPointerException e) {
                    log.error("[WebConference@BigBlueButton] Failed to parse creation response", e);
                    handler.handle(new Either.Left<>(e.toString()));
                }
            });
            response.exceptionHandler(throwable -> {
                log.error("[WebConference@BigBlueButton] Failed to create meeting. An error is catch by exception handler", throwable);
                handler.handle(new Either.Left<>(throwable.toString()));
            });
        });
        request.putHeader("Client-Server", this.source);
        request.putHeader("Client-Structure", structure);
        request.putHeader("Client-Locale", locale);
        request.end();
    }

    public void end(String meetingId, String moderatorPW, Handler<Either<String, Boolean>> handler) {
        String parameters = "meetingID=" + meetingId + "&password=" + moderatorPW;
        String checksum = checksum(Actions.END + parameters + this.secret);
        parameters = parameters + "&checksum=" + checksum;
        HttpClientRequest request = httpClient.getAbs(this.host + this.apiEndpoint + "/" + Actions.END + "?" + parameters, response -> {
            if (response.statusCode() != 200) {
                String message = "[WebConference@BigBlueButton] Failed to end meeting : " + meetingId;
                log.error(message);
                handler.handle(new Either.Left<>(message));
            } else {
                response.bodyHandler(body -> {
                    try {
                        Document res = parseResponse(body);
                        XPathFactory xpf = XPathFactory.newInstance();
                        XPath path = xpf.newXPath();
                        String returnCode = path.evaluate("/response/returncode", res.getDocumentElement());

                        if (!"SUCCESS".equals(returnCode)) {
                            handler.handle(new Either.Left<>("[WebConference@BigBlueButton] Response is not SUCCESS"));
                            return;
                        }

                        handler.handle(new Either.Right<>(true));
                    } catch (XPathExpressionException | NullPointerException e) {
                        log.error("[WebConference@BigBlueButton] Failed to parse end meeting response body");
                        handler.handle(new Either.Left<>(e.toString()));
                    }
                });
                response.exceptionHandler(throwable -> {
                    log.error("[WebConference@BigBlueButton] Failed to end meeting. An error is catch by exception handler. Meetind : " + meetingId, throwable);
                    handler.handle(new Either.Left<>(throwable.toString()));
                });
            }
        });
        request.putHeader("Client-Server", this.source);
        request.end();
    }

    public void isMeetingRunning(String meetingId, Handler<Either<String, Boolean>> handler) {
        String parameters = "meetingID=" + meetingId;
        String checksum = checksum(Actions.IS_MEETING_RUNNING + parameters + this.secret);
        parameters = parameters + "&checksum=" + checksum;
        HttpClientRequest request = httpClient.getAbs(this.host + this.apiEndpoint + "/" + Actions.IS_MEETING_RUNNING + "?" + parameters, response -> {
            if (response.statusCode() != 200) {
                String message = "[WebConference@BigBlueButton] Failed check meeting status : " + meetingId;
                log.error(message);
                handler.handle(new Either.Left<>(message));
            } else {
                response.bodyHandler(body -> {
                    try {
                        Document res = parseResponse(body);
                        XPathFactory xpf = XPathFactory.newInstance();
                        XPath path = xpf.newXPath();
                        String returnCode = path.evaluate("/response/returncode", res.getDocumentElement());

                        if (!"SUCCESS".equals(returnCode)) {
                            handler.handle(new Either.Left<>("[WebConference@BigBlueButton] Response is not SUCCESS"));
                            return;
                        }

                        String running = path.evaluate("/response/running", res.getDocumentElement());
                        handler.handle(new Either.Right<>(Boolean.parseBoolean(running)));
                    } catch (XPathExpressionException | NullPointerException e) {
                        log.error("[WebConference@BigBlueButton] Failed to parse end meeting response body");
                        handler.handle(new Either.Left<>(e.toString()));
                    }
                });
                response.exceptionHandler(throwable -> {
                    log.error("[WebConference@BigBlueButton] Failed to check meeting status. An error is catch by exception handler. Meeting : " + meetingId, throwable);
                    handler.handle(new Either.Left<>(throwable.toString()));
                });
            }
        });
        request.putHeader("Client-Server", this.source);
        request.end();
    }

    private static class BigBlueButtonHolder {
        private static final BigBlueButton instance = new BigBlueButton();

        private BigBlueButtonHolder() {
        }
    }

    public void addWebHook(String webhook, Handler<Either<String, String>> handler) {
        String parameter = "callbackURL=" + this.encodeParams(webhook);
        String checksum = checksum(Actions.CREATE_HOOK + parameter + this.secret);
        String url = this.host + this.apiEndpoint + "/" + Actions.CREATE_HOOK + "?" + parameter + "&checksum=" + checksum;
        log.info("[WebConference@BigBlueButton] web hook end point : " + url);
        HttpClientRequest request = this.httpClient.getAbs(url, response -> {
            if (response.statusCode() != 200) {
                String message = "[WebConference@BigBlueButton] Failed to add webhook";
                log.error(message);
                handler.handle(new Either.Left<>(message));
            } else {
                response.bodyHandler(body -> {
                    try {
                        Document res = parseResponse(body);
                        XPathFactory xpf = XPathFactory.newInstance();
                        XPath path = xpf.newXPath();
                        String returnCode = path.evaluate("/response/returncode", res.getDocumentElement());

                        if (!"SUCCESS".equals(returnCode)) {
                            handler.handle(new Either.Left<>("[WebConference@BigBlueButton] Response is not SUCCESS"));
                            return;
                        }

                        String hookId = path.evaluate("/response/hookID", res.getDocumentElement());
                        handler.handle(new Either.Right<>(hookId));
                    } catch (XPathExpressionException | NullPointerException e) {
                        log.error("[WebConference@BigBlueButton] Failed to parse web hook response", e);
                        handler.handle(new Either.Left<>(e.toString()));
                    }
                });
                response.exceptionHandler(throwable -> {
                    log.error("[WebConference@BigBlueButton] Failed to register web hook", throwable);
                    handler.handle(new Either.Left<>(throwable.toString()));
                });
            }
        });
        request.putHeader("Client-Server", this.source);
        request.end();
    }
}
```